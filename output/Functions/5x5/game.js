// Generated by CoffeeScript 2.0.3
(function() {
  var GRID_SIZE, MIN_WORD_LENGTH, alphabet, count, fs, grid, inRange, inputCallback, isInteger, isWord, j, k, letter, moveCount, owl2, printGrid, promptForTile1, promptForTile2, randomLetter, ref, ref1, score, scoreMove, stdin, strToCoordinates, tileCounts, tileValues, totalTiles, usedWords, word, wordList, wordsThroughTile, x, y,
    indexOf = [].indexOf;

  fs = require('fs');

  owl2 = fs.readFileSync('OWL2.txt', 'utf8');

  GRID_SIZE = 5;

  MIN_WORD_LENGTH = 2;

  wordList = owl2.match(/^(\w+)/mg);

  wordList = (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = wordList.length; j < len; j++) {
      word = wordList[j];
      if (word.length <= GRID_SIZE) {
        results.push(word);
      }
    }
    return results;
  })();

  isWord = function(str) {
    return indexOf.call(wordList, str) >= 0;
  };

  inRange = function(x, y) {
    return (0 <= x && x < GRID_SIZE) && (0 <= y && y < GRID_SIZE);
  };

  isInteger = function(num) {
    return num === Math.round(num);
  };

  // Probabilities are taken from Scrabble, except that there are no blanks.
  // See http://www.hasbro.com/scrabble/en_us/saqGeneral.cfm
  tileCounts = {
    A: 9,
    B: 2,
    C: 2,
    D: 4,
    E: 12,
    F: 2,
    G: 3,
    H: 2,
    I: 9,
    J: 1,
    K: 1,
    L: 4,
    M: 2,
    N: 6,
    O: 8,
    P: 2,
    Q: 1,
    R: 6,
    S: 4,
    T: 6,
    U: 4,
    V: 2,
    W: 2,
    X: 1,
    Y: 2,
    Z: 1
  };

  totalTiles = 0;

  for (letter in tileCounts) {
    count = tileCounts[letter];
    totalTiles += count;
  }

  // JavaScript hashes are unordered, so we need to make our own key array:
  alphabet = ((function() {
    var results;
    results = [];
    for (letter in tileCounts) {
      results.push(letter);
    }
    return results;
  })()).sort();

  randomLetter = function() {
    var j, len, randomNumber, x;
    randomNumber = Math.ceil(Math.random() * totalTiles);
    x = 1;
    for (j = 0, len = alphabet.length; j < len; j++) {
      letter = alphabet[j];
      x += tileCounts[letter];
      if (x > randomNumber) {
        return letter;
      }
    }
  };

  // grid is a 2D array: grid[col][row], where 0, 0 is the upper-left corner
  // grid = [ col, col, col, col, col,
  //          col, col, col, col, col,
  //          col, col, col, col, col,
  //          col, col, col, col, col,
  //          col, col, col, col, col]
  // grid = [ [ 'A', 'W', 'U', 'W', 'I' ],
  //         [ 'A', 'T', 'L', 'C', 'M' ],
  //         [ 'A', 'F', 'E', 'E', 'P' ],       0----->y
  //         [ 'C', 'O', 'R', 'D', 'O' ],       |
  //         [ 'H', 'H', 'A', 'I', 'U' ] ]      |
  grid = (function() {
    var j, ref, results;
    results = [];
    // row        x
    for (x = j = 0, ref = GRID_SIZE; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      results.push((function() {
        var k, ref1, results1;
        results1 = [];
        // col
        for (y = k = 0, ref1 = GRID_SIZE; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
          results1.push(randomLetter());
        }
        return results1;
      })());
    }
    return results;
  })();

  // console.log grid
  printGrid = function() {
    var i, row, rowSeparator, rowStrings, rows;
    // Transpose the grid so we can draw rows
    rows = (function() {
      var j, ref, results;
      results = [];
      for (x = j = 0, ref = GRID_SIZE; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var k, ref1, results1;
          results1 = [];
          for (y = k = 0, ref1 = GRID_SIZE; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
            results1.push(grid[y][x]);
          }
          return results1;
        })());
      }
      return results;
    })();
    // console.log rows
    rowStrings = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = rows.length; j < len; j++) {
        row = rows[j];
        results.push(' ' + row.join(' | '));
      }
      return results;
    })();
    rowSeparator = ((function() {
      var j, ref, results;
      results = [];
      for (i = j = 1, ref = GRID_SIZE * 4; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        results.push('-');
      }
      return results;
    })()).join('');
    return console.log('\n' + rowStrings.join(`\n${rowSeparator}\n`) + '\n');
  };

  // Each letter has the same point value as in Scrabble.
  tileValues = {
    A: 1,
    B: 3,
    C: 3,
    D: 2,
    E: 1,
    F: 4,
    G: 2,
    H: 4,
    I: 1,
    J: 8,
    K: 5,
    L: 1,
    M: 3,
    N: 1,
    O: 1,
    P: 3,
    Q: 10,
    R: 1,
    S: 1,
    T: 1,
    U: 1,
    V: 4,
    W: 4,
    X: 8,
    Y: 4,
    Z: 10
  };

  moveCount = 0;

  score = 0;

  usedWords = [];

  scoreMove = function(grid, swapCoordinates) {
    var j, k, len, len1, moveScore, multiplier, newWords, words, x1, x2, y1, y2;
    ({x1, y1, x2, y2} = swapCoordinates);
    words = wordsThroughTile(grid, x1, y1).concat(wordsThroughTile(grid, x2, y2));
    moveScore = multiplier = 0;
    newWords = [];
    for (j = 0, len = words.length; j < len; j++) {
      word = words[j];
      if (!(indexOf.call(usedWords, word) < 0 && indexOf.call(newWords, word) < 0)) {
        continue;
      }
      multiplier++;
      for (k = 0, len1 = word.length; k < len1; k++) {
        letter = word[k];
        moveScore += tileValues[letter];
      }
      newWords.push(word);
    }
    usedWords = usedWords.concat(newWords);
    moveScore *= multiplier;
    return {moveScore, newWords};
  };

  wordsThroughTile = function(grid, x, y) {
    var addTiles, j, k, l, len, length, offset, range, ref, ref1, ref2, results, str, strings;
    strings = [];
    for (length = j = ref = MIN_WORD_LENGTH, ref1 = GRID_SIZE; ref <= ref1 ? j <= ref1 : j >= ref1; length = ref <= ref1 ? ++j : --j) {
      range = length - 1;
      addTiles = function(func) {
        var i;
        return strings.push(((function() {
          var k, ref2, results;
          results = [];
          for (i = k = 0, ref2 = range; 0 <= ref2 ? k <= ref2 : k >= ref2; i = 0 <= ref2 ? ++k : --k) {
            results.push(func(i));
          }
          return results;
        })()).join(''));
      };
      for (offset = k = 0, ref2 = length; 0 <= ref2 ? k < ref2 : k > ref2; offset = 0 <= ref2 ? ++k : --k) {
        // Vertical
        if (inRange(x - offset, y) && inRange(x - offset + range, y)) {
          addTiles(function(i) {
            return grid[x - offset + i][y];
          });
        }
        // Horizontal
        if (inRange(x, y - offset) && inRange(x, y - offset + range)) {
          addTiles(function(i) {
            return grid[x][y - offset + i];
          });
        }
        // Diagonal(upper-left to lower-right)
        if (inRange(x - offset, y - offset) && inRange(x - offset + range, y - offset + range)) {
          addTiles(function(i) {
            return grid[x - offset + i][y - offset + i];
          });
        }
        // Diagonal (lower-left to upper-right)
        if (inRange(x - offset, y + offset) && inRange(x - offset + range, y + offset - range)) {
          addTiles(function(i) {
            return grid[x - offset + i][y + offset - i];
          });
        }
      }
    }
    results = [];
    for (l = 0, len = strings.length; l < len; l++) {
      str = strings[l];
      if (isWord(str)) {
        results.push(str);
      }
    }
    return results;
  };

  console.log("Welcome to 5x5!");

  for (x = j = 0, ref = GRID_SIZE; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = GRID_SIZE; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      scoreMove(grid, {
        x1: x,
        x2: x,
        y1: y,
        y2: y
      });
    }
  }

  if (usedWords.length !== 0) {
    console.log(`Initially used words:\n${usedWords.join(', ')}`);
  }

  console.log("Please choose a tile in the form (x, y).");

  stdin = process.openStdin();

  stdin.setEncoding('utf8');

  inputCallback = null;

  stdin.on('data', function(input) {
    return inputCallback(input);
  });

  promptForTile1 = function() {
    printGrid();
    console.log("Please enter coordinates for the first tile.");
    return inputCallback = function(input) {
      var e;
      try {
        ({x, y} = strToCoordinates(input));
      } catch (error) {
        e = error;
        console.log(e);
        return;
      }
      return promptForTile2(x, y);
    };
  };

  promptForTile2 = function(x1, y1) {
    console.log("Please enter coordinates for the second tile.");
    return inputCallback = function(input) {
      var e, moveScore, newWords, x2, y2;
      try {
        ({
          x: x2,
          y: y2
        } = strToCoordinates(input));
      } catch (error) {
        e = error;
        console.log(e);
        return;
      }
      if (x1 === x2 && y1 === y2) {
        return console.log("The second tile must be different from the first.");
      } else {
        console.log(`Swapping (${x1}, ${y1}) with (${x2}, ${y2})...`);
        x1--;
        x2--;
        y1--;
        y2--;
        [grid[x1][y1], grid[x2][y2]] = [grid[x2][y2], grid[x1][y1]];
        ({moveScore, newWords} = scoreMove(grid, {x1, y1, x2, y2}));
        if (moveScore !== 0) {
          console.log(`You formed the following word(s):\n${newWords.join(', ')}\n`);
          score += moveScore;
        }
        moveCount++;
        console.log(`Your score after ${moveCount} moves: ${score}`);
        return promptForTile1();
      }
    };
  };

  strToCoordinates = function(input) {
    var halves;
    halves = input.split(',');
    if (halves.length === 2) {
      x = parseFloat(halves[0]);
      y = parseFloat(halves[1]);
      if (!isInteger(x) || !isInteger(y)) {
        return console.log("Each coordinate must be an integer.");
      } else if (!inRange(x - 1, y - 1)) {
        return console.log(`Each coordinate must be between 1 and ${GRID_SIZE}`);
      } else {
        return {x, y};
      }
    } else {
      return console.log('Input must be of the form `x, y`.');
    }
  };

  promptForTile1();

}).call(this);
