// Generated by CoffeeScript 2.0.3
(function() {
  var GRID_SIZE, MIN_WORD_LENGTH, alphabet, count, fs, grid, inRange, inputCallback, isInteger, isWord, j, k, letter, moveCount, owl2, printGrid, promptForTile1, promptForTile2, randomLetter, ref, ref1, score, scoreMove, stdin, strToCoordinates, tileCounts, tileValues, totalTiles, usedWords, word, wordList, wordsThroughTile, x, y,
    indexOf = [].indexOf;

  fs = require('fs'); // 引用库 fs

  owl2 = fs.readFileSync('OWL2.txt', 'utf8'); // 读取文件OWL2.txt产生字串owl2

  GRID_SIZE = 5; // 网格大小

  MIN_WORD_LENGTH = 2; // 最小有效字长度

  wordList = owl2.match(/^(\w+)/mg); // 过滤出单词

  wordList = (function() {
    var j, len, results;
    results = [];
    // 过滤出符合网格尺寸的单词
    for (j = 0, len = wordList.length; j < len; j++) {
      word = wordList[j];
      if (word.length <= GRID_SIZE) {
        results.push(word);
      }
    }
    return results;
  })();

  isWord = function(str) { // 字串有效性判断
    return indexOf.call(wordList, str) >= 0;
  };

  inRange = function(x, y) { // 坐标有效性判断
    return (0 <= x && x < GRID_SIZE) && (0 <= y && y < GRID_SIZE);
  };

  isInteger = function(num) { // 判断输入的数字是否为整数
    return num === Math.round(num);
  };

  // Probabilities are taken from Scrabble, except that there are no blanks.
  // See http://www.hasbro.com/scrabble/en_us/saqGeneral.cfm
  tileCounts = { // 不同字母相对权重，出现的概率
    A: 9,
    B: 2,
    C: 2,
    D: 4,
    E: 12,
    F: 2,
    G: 3,
    H: 2,
    I: 9,
    J: 1,
    K: 1,
    L: 4,
    M: 2,
    N: 6,
    O: 8,
    P: 2,
    Q: 1,
    R: 6,
    S: 4,
    T: 6,
    U: 4,
    V: 2,
    W: 2,
    X: 1,
    Y: 2,
    Z: 1
  };

  totalTiles = 0;

  for (letter in tileCounts) {
    count = tileCounts[letter];
    totalTiles += count;
  }

  // JavaScript hashes are unordered, so we need to make our own key array:
  alphabet = ((function() {
    var results;
    results = [];
    for (letter in tileCounts) {
      results.push(letter);
    }
    return results;
  })()).sort(); // [A, B, .. , Z]

  randomLetter = function() { // 随机产生一个字母
    var j, len, randomNumber, x;
    randomNumber = Math.ceil(Math.random() * totalTiles);
    x = 1;
    for (j = 0, len = alphabet.length; j < len; j++) {
      letter = alphabet[j];
      x += tileCounts[letter];
      if (x > randomNumber) {
        return letter;
      }
    }
  };

  // grid is a 2D array: grid[col][row], where 0, 0 is the upper-left corner
  grid = (function() {
    var j, ref, results;
    results = [];
    // 此处的grid为列数组
    for (x = j = 0, ref = GRID_SIZE; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      results.push((function() {
        var k, ref1, results1;
        results1 = [];
        // grid[col][row]
        for (y = k = 0, ref1 = GRID_SIZE; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
          results1.push(randomLetter());
        }
        return results1;
      })());
    }
    return results;
  })();

  printGrid = function() { // printGrid在终端画出网格grid
    var i, row, rowSeparator, rowStrings, rows;
    // Transpose the grid so we can draw rows
    rows = (function() {
      var j, ref, results;
      results = [];
      // 将列数组转为行数组 [这里面是不同的行[这里是不同的列]，[这里是不同的列]，[这里是不同的列]，[这里是不同的列]，[这里是不同的列]，[这里是不同的列]]
      for (x = j = 0, ref = GRID_SIZE; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var k, ref1, results1;
          results1 = [];
          // rows[row][col]
          for (y = k = 0, ref1 = GRID_SIZE; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
            results1.push(grid[y][x]);
          }
          return results1;
        })());
      }
      return results;
    })();
    rowStrings = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = rows.length; j < len; j++) {
        row = rows[j];
        results.push(' ' + row.join(' | '));
      }
      return results;
    })();
    rowSeparator = ((function() {
      var j, ref, results;
      results = [];
      for (i = j = 1, ref = GRID_SIZE * 4; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        results.push('-');
      }
      return results;
    })()).join('');
    return console.log('\n' + rowStrings.join(`\n${rowSeparator}\n`) + '\n');
  };

  // Each letter has the same point value as in Scrabble.
  tileValues = {
    A: 1,
    B: 3,
    C: 3,
    D: 2,
    E: 1,
    F: 4,
    G: 2,
    H: 4,
    I: 1,
    J: 8,
    K: 5,
    L: 1,
    M: 3,
    N: 1,
    O: 1,
    P: 3,
    Q: 10,
    R: 1,
    S: 1,
    T: 1,
    U: 1,
    V: 4,
    W: 4,
    X: 8,
    Y: 4,
    Z: 10
  };

  moveCount = 0; // 游戏步骤记录

  score = 0; // 游戏得分

  usedWords = []; // 已经出现过的word

  scoreMove = function(grid, swapCoordinates) {
    var j, k, len, len1, moveScore, multiplier, newWords, words, x1, x2, y1, y2;
    ({x1, y1, x2, y2} = swapCoordinates);
    words = wordsThroughTile(grid, x1, y1).concat(wordsThroughTile(grid, x2, y2));
    moveScore = multiplier = 0; // 初始化
    newWords = []; // 初始化
    for (j = 0, len = words.length; j < len; j++) {
      word = words[j];
      if (!(indexOf.call(usedWords, word) < 0 && indexOf.call(newWords, word) < 0)) {
        continue;
      }
      multiplier++; // new word 的数量
      // 累加每个word对应的score
      for (k = 0, len1 = word.length; k < len1; k++) {
        letter = word[k];
        moveScore += tileValues[letter];
      }
      newWords.push(word); // 更新newWords数组
    }
    usedWords = usedWords.concat(newWords); // 用newWords更新usedWords
    moveScore *= multiplier; // 一次坐标字母交换，生成的新字越多，分数变动moveScore的愈多
    return {moveScore, newWords};
  };

  wordsThroughTile = function(grid, x, y) { // 通过特定坐标的words
    var addTiles, j, k, l, len, length, offset, range, ref, ref1, ref2, results, str, strings;
    strings = [];
    // 确定字符的长度
    for (length = j = ref = MIN_WORD_LENGTH, ref1 = GRID_SIZE; ref <= ref1 ? j <= ref1 : j >= ref1; length = ref <= ref1 ? ++j : --j) {
      range = length - 1; // 从起点起，移动的长度
      addTiles = function(func) {
        var i;
        return strings.push(((function() {
          var k, ref2, results;
          results = [];
          for (i = k = 0, ref2 = range; 0 <= ref2 ? k <= ref2 : k >= ref2; i = 0 <= ref2 ? ++k : --k) {
            results.push(func(i));
          }
          return results;
        })()).join('')); // 添加一个字串到strings数组中
      };
      // offset坐标某侧移动的距离，字串的起点
      for (offset = k = 0, ref2 = length; 0 <= ref2 ? k < ref2 : k > ref2; offset = 0 <= ref2 ? ++k : --k) {
        // Vertical                                          # 此处的grid为行数组
        if (inRange(x - offset, y) && inRange(x - offset + range, y)) { // 特定长度字符的起点与终点有效性检测
          addTiles(function(i) {
            return grid[x - offset + i][y];
          });
        }
        // Horizontal
        if (inRange(x, y - offset) && inRange(x, y - offset + range)) {
          addTiles(function(i) {
            return grid[x][y - offset + i];
          });
        }
        // Diagonal(upper-left to lower-right)
        if (inRange(x - offset, y - offset) && inRange(x - offset + range, y - offset + range)) {
          addTiles(function(i) {
            return grid[x - offset + i][y - offset + i];
          });
        }
        // Diagonal (lower-left to upper-right)
        if (inRange(x - offset, y + offset) && inRange(x - offset + range, y + offset - range)) {
          addTiles(function(i) {
            return grid[x - offset + i][y + offset - i];
          });
        }
      }
    }
    results = [];
    for (l = 0, len = strings.length; l < len; l++) {
      str = strings[l];
      if (isWord(str)) {
        results.push(str);
      }
    }
    return results;
  };

  // CMD-LINE IO
  console.log("Welcome to 5x5!"); // (1)

  for (x = j = 0, ref = GRID_SIZE; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = GRID_SIZE; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      scoreMove(grid, {
        x1: x,
        x2: x,
        y1: y,
        y2: y
      });
    }
  }

  if (usedWords.length !== 0) { // (2)
    // 输出多行字串，字串定界符 """
    console.log(`Initially used words:\n${usedWords.join(', ')}`);
  }

  console.log("Please choose a tile in the form (x, y)."); // (3)

  stdin = process.openStdin();

  stdin.setEncoding('utf8');

  inputCallback = null;

  stdin.on('data', function(input) {
    return inputCallback(input); // NOTE: 绑定事件
  });

  promptForTile1 = function() {
    printGrid();
    console.log("Please enter coordinates for the first tile."); // stdin.on 'data', (input) -> inputCallback input
    return inputCallback = function(input) { // 事件处理，输入回调
      var e;
      try {
        ({x, y} = strToCoordinates(input));
        console.log({x, y});
      } catch (error) {
        e = error;
        console.log(e);
        return;
      }
      return promptForTile2(x, y);
    };
  };

  promptForTile2 = function(x1, y1) {
    console.log("Please enter coordinates for the second tile.");
    return inputCallback = function(input) {
      var e, moveScore, newWords, x2, y2;
      try {
        ({
          x: x2,
          y: y2
        } = strToCoordinates(input));
      } catch (error) {
        e = error;
        console.log(e);
        return;
      }
      if (x1 === x2 && y1 === y2) {
        return console.log("The second tile must be different from the first.");
      } else {
        console.log(`Swapping (${x1}, ${y1}) with (${x2}, ${y2})...`);
        x1--;
        x2--;
        y1--;
        y2--;
        [grid[x1][y1], grid[x2][y2]] = [grid[x2][y2], grid[x1][y1]];
        ({moveScore, newWords} = scoreMove(grid, {x1, y1, x2, y2}));
        if (moveScore !== 0) {
          console.log(`You formed the following word(s):\n${newWords.join(', ')}\n`);
          score += moveScore; // 更新分数score
        }
        moveCount++; // 移动的次数，记录游戏的步骤，输入一对坐标(x1,y1),(x2,y2)为移动一次（也可以说调用一次 promptForTile2(x1,y1)
        console.log(`Your score after ${moveCount} moves: ${score}`);
        return promptForTile1();
      }
    };
  };

  strToCoordinates = function(input) { // command-line 输入的都为字串
    var halves;
    halves = input.split(','); // str：input 转为 array of strings：halves
    if (halves.length === 2) {
      x = parseFloat(halves[0]);
      y = parseFloat(halves[1]);
      if (!isInteger(x) || !isInteger(y)) { // 整数判断
        return console.log("Each coordinate must be an integer.");
      } else if (!inRange(x - 1, y - 1)) { // 范围判断：起点（0，0）变为（1，1）
        return console.log(`Each coordinate must be between 1 and ${GRID_SIZE}`);
      } else {
        return {x, y};
      }
    } else {
      return console.log('Input must be of the form `x, y`.');
    }
  };

  promptForTile1(); // (4)

}).call(this);
